<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Armored Assaultl ðŸª–</title>
  <link rel="icon" href="tankLogo.png">
  <meta property="og:title"
    content="Armored Assault ðŸª–" />
  <meta property="og:image"
    content="tankLogo.png" />
  <meta property="og:description"
    content="Multiplayer - Tank War Game" />
  <meta property="og:url"
    content="https://tank-online.vercel.app" />
  <meta property="og:type"
    content="website" />
  <script
    src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js">
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');
    
    :root {
      --army-green: #4a5c38;
      --army-dark: #2e3b23;
      --danger: #d32f2f;
      --success: #4caf50;
      --accent: #ffd700;
      --glass: rgba(15, 15, 15, 0.95);
    }
    
    body {
      margin: 0;
      overflow: hidden;
      background-color: #1a1a1a;
      font-family: 'Black Ops One', cursive;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      color: white;
      transition: filter 0.1s;
    }
    
    @keyframes shake-blur {
      0% {
        transform: translate(1px, 1px) rotate(0deg);
        filter: blur(2px);
      }
      
      10% {
        transform: translate(-1px, -2px) rotate(-1deg);
        filter: blur(4px);
      }
      
      20% {
        transform: translate(-3px, 0px) rotate(1deg);
      }
      
      30% {
        transform: translate(3px, 2px) rotate(0deg);
        filter: blur(2px);
      }
      
      40% {
        transform: translate(1px, -1px) rotate(1deg);
      }
      
      50% {
        transform: translate(-1px, 2px) rotate(-1deg);
      }
      
      60% {
        transform: translate(-3px, 1px) rotate(0deg);
      }
      
      70% {
        transform: translate(3px, 1px) rotate(-1deg);
        filter: blur(0px);
      }
      
      80% {
        transform: translate(-1px, -1px) rotate(1deg);
      }
      
      90% {
        transform: translate(1px, 2px) rotate(0deg);
      }
      
      100% {
        transform: translate(1px, -2px) rotate(-1deg);
      }
    }
    
    .shake-effect {
      animation: shake-blur 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }
    
    /* --- Menus --- */
    .overlay-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: var(--glass);
      backdrop-filter: blur(4px);
      padding: 2rem;
      border: 3px solid var(--army-green);
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
      z-index: 100;
      width: 85%;
      max-width: 400px;
    }
    
    h1 {
      color: #8f9e78;
      font-size: 1.8rem;
      margin-top: 0;
    }
    
    .code-box {
      font-size: 2.2rem;
      color: var(--accent);
      background: #000;
      padding: 10px;
      margin: 15px 0;
      border-radius: 8px;
      border: 2px dashed #444;
      cursor: pointer;
      letter-spacing: 4px;
    }
    
    input[type=number] {
      width: 80%;
      padding: 12px;
      font-size: 1.2rem;
      text-align: center;
      background: #2a2a2a;
      border: 2px solid #444;
      color: white;
      outline: none;
      border-radius: 5px;
      margin-bottom: 10px;
      font-family: monospace;
      -moz-appearance: textfield;
    }
    
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    button {
      width: 90%;
      padding: 14px;
      font-size: 1rem;
      cursor: pointer;
      background: var(--army-green);
      color: white;
      border: none;
      border-radius: 5px;
      margin: 8px 0;
      font-family: 'Black Ops One', cursive;
      box-shadow: 0 4px 0 var(--army-dark);
      text-transform: uppercase;
    }
    
    button:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 var(--army-dark);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-return {
      background: #444;
      box-shadow: 0 4px 0 #222;
    }
    
    .btn-quit {
      background: var(--danger);
      box-shadow: 0 4px 0 #500;
    }
    
    /* --- Notification Popup --- */
    #disconnect-modal {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 200;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    
    #disconnect-msg {
      color: var(--accent);
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-align: center;
    }
    
    #disconnect-sub {
      font-size: 1.2rem;
      margin-bottom: 10px;
      opacity: 0.8;
      color: #fff;
    }
    
    #disconnect-timer {
      font-size: 5rem;
      color: var(--danger);
    }
    
    /* --- HUD --- */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: none;
    }
    
    .hud-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 12px;
      width: 180px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      border-radius: 10px;
      pointer-events: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .bar-bg {
      width: 100%;
      height: 8px;
      background: #333;
      margin: 4px 0 10px;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      width: 100%;
      transition: width 0.3s ease;
    }
    
    #hp-local {
      background: #4caf50;
    }
    
    #hp-remote {
      background: #f44336;
    }
    
    .ammo-wrap {
      display: flex;
      gap: 3px;
      margin-bottom: 0;
    }
    
    .ammo-status {
      font-size: 0.6rem;
      color: var(--accent);
      margin-bottom: 2px;
      height: 12px;
      text-transform: uppercase;
    }
    .ammo-status.reload{
      animation:blink 0.5s linear infinite;
    }
    @keyframes bullet-pulse {
      0% {
        opacity: 1;
      }
      
      50% {
        opacity: 0.3;
      }
      
      100% {
        opacity: 1;
      }
    }
    
    .bullet.loading {
      background: #666;
      animation: bullet-pulse 1s infinite;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    }
    
    .bullet {
      width: 8px;
      height: 14px;
      background: #333;
      border-radius: 1px;
    }
    
    .bullet.active {
      background: var(--accent);
      box-shadow: 0 0 5px var(--accent);
    }
    
    .bullet.loading {
      background: #555;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      50% {
        opacity: 0.5;
      }
    }
    
    /* Microphone Button */
    #mic-btn {
      position: absolute;
      top: 135px;
      left: 10px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(211, 47, 47, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      cursor: pointer;
      pointer-events: auto;
      backdrop-filter: blur(5px);
      transition: background 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    #mic-btn.on {
      background: rgba(76, 175, 80, 0.9);
      border-color: #fff;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
    }
    
    #top-quit {
      position: absolute;
      top: 10px;
      right: 10px;
      width: auto;
      padding: 8px 15px;
      pointer-events: auto;
    }
    
    /* --- Mobile Controls --- */
    #mobile-controls {
      display: none;
      position: absolute;
      bottom: 30px;
      left: 0;
      width: 100%;
      pointer-events: none;
    }
    
    #joy-base {
      position: absolute;
      left: 30px;
      bottom: 0;
      width: 120px;
      height: 120px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      pointer-events: auto;
    }
    
    #joy-stick {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    
    #btn-fire {
      position: absolute;
      right: 30px;
      bottom: 10px;
      width: 80px;
      height: 80px;
      background: rgba(255, 0, 0, 0.3);
      border: 3px solid rgba(255, 0, 0, 0.5);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    
    canvas {
      display: block;
    }
  </style>
</head>

<body>
  
  <div id="disconnect-modal">
    <div id="disconnect-msg">
      DISCONNECTED</div>
    <div id="checkWin"
      style="color:#f00;margin:8px 0;display:none;">
      OPPONENT BROKE CONTACT.
    </div>
    <div id="disconnect-sub">
      RETURNING TO LOBBY</div>
    <div id="disconnect-timer">3
    </div>
  </div>
  
  <div id="menu-main"
    class="overlay-menu">
    <h1>ARMORED ASSAULT</h1>
    <button onclick="showHost()">Host
      Game</button>
    <div
      style="margin: 10px 0; opacity: 0.5;">
      - OR -</div>
    <input type="number" id="join-id"
      placeholder="6-DIGIT CODE">
    <button id="btn-join"
      onclick="joinGame()">Join
      Game</button>
  </div>
  
  <div id="menu-host"
    class="overlay-menu"
    style="display:none">
    <h1>MATCH ROOM</h1>
    <p>TAP CODE TO COPY</p>
    <div id="code-display"
      class="code-box"
      onclick="copyCode()">...
    </div>
    <p id="host-status">Waiting for
      opponent...</p>
    <button class="btn-return"
      onclick="handleQuit()">Return
      Home</button>
  </div>
  
  <div id="menu-over"
    class="overlay-menu"
    style="display:none">
    <h2 id="over-title">NOT VERIFIED
    </h2>
    <div id="rematch-msg"
      style="color:var(--accent); font-size: 0.9rem; min-height: 20px; margin-bottom:10px;">
    </div>
    <button id="btn-rematch"
      onclick="requestRematch()">Rematch</button>
    <button class="btn-quit"
      onclick="handleQuit()">Quit</button>
  </div>
  
  <div id="ui-layer">
    <button id="top-quit"
      class="btn-quit"
      onclick="handleQuit()">QUIT</button>
    
    <div class="hud-panel">
      <div style="font-size:0.7rem">
        YOU</div>
      <div class="bar-bg">
        <div id="hp-local"
          class="bar-fill">
        </div>
      </div>
      <div
        style="font-size:0.7rem;color:red;">
        ENEMY</div>
      <div class="bar-bg">
        <div id="hp-remote"
          class="bar-fill">
        </div>
      </div>
      <div id="ammo-status"
        class="ammo-status"></div>
      <div id="ammo-count"
        class="ammo-wrap"></div>
      
    </div>
    
    <div id="mic-btn"
      onclick="toggleMic()">ðŸŽ™
    </div>
    
    <div id="mobile-controls">
      <div id="joy-base">
        <div id="joy-stick">
        </div>
      </div>
      <div id="btn-fire"
        ontouchstart="fireBullet(event)">
        FIRE</div>
    </div>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  <audio id="remote-audio" autoplay
    playsinline></audio>
  
  <script>
    /* --- AUDIO SYSTEM (Web Audio API) --- */
    const audioCtx = new(window
      .AudioContext || window
      .webkitAudioContext)();
    
    const SoundFX = {
      // Helper: Calculate volume based on distance (0 to 1)
      getVol: (x, y) => {
        if (x === null || y ===
          null)
      return 1.0; // Local sound = Max volume
        
        // Calculate distance between sound source and player
        const dist = Math.hypot(x -
          player.x, y - player.y);
        const maxDist =
        2000; // Sound fades out completely at 2000px
        
        let vol = 1 - (dist /
          maxDist);
        return Math.max(0,
        vol); // Ensure volume never goes below 0
      },
      
      shoot: (x = null, y = null) => {
        if (audioCtx.state ===
          'suspended') audioCtx
          .resume();
        
        const vol = SoundFX.getVol(
          x, y);
        if (vol <= 0)
      return; // Don't play if too far away
        
        const bufferSize = audioCtx
          .sampleRate * 0.5;
        const buffer = audioCtx
          .createBuffer(1,
            bufferSize, audioCtx
            .sampleRate);
        const data = buffer
          .getChannelData(0);
        
        for (let i = 0; i <
          bufferSize; i++) {
          data[i] = Math.random() *
            2 - 1;
        }
        
        const noise = audioCtx
          .createBufferSource();
        noise.buffer = buffer;
        
        const filter = audioCtx
          .createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency
          .setValueAtTime(1000,
            audioCtx.currentTime);
        filter.frequency
          .exponentialRampToValueAtTime(
            50, audioCtx
            .currentTime + 0.3);
        
        const gain = audioCtx
          .createGain();
        // Base volume is 2.5, multiplied by our distance factor
        gain.gain.setValueAtTime(
          2.5 * vol, audioCtx
          .currentTime);
        gain.gain
          .exponentialRampToValueAtTime(
            0.01, audioCtx
            .currentTime + 0.3);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx
          .destination);
        noise.start();
      },
      
      hit: (x = null, y = null) => {
        if (audioCtx.state ===
          'suspended') audioCtx
          .resume();
        
        const vol = SoundFX.getVol(
          x, y);
        if (vol <= 0) return;
        
        const t = audioCtx
          .currentTime;
        const freqs = [800, 2240,
          3600
        ];
        
        freqs.forEach((f, i) => {
          const osc = audioCtx
            .createOscillator();
          const gain = audioCtx
            .createGain();
          
          osc.type = i === 1 ?
            'triangle' : 'sine';
          osc.frequency
            .setValueAtTime(f,
              t);
          
          const baseVol = i ===
            0 ? 0.1 : 0.025;
          gain.gain
            .setValueAtTime(
              baseVol * vol, t);
          gain.gain
            .exponentialRampToValueAtTime(
              0.001, t + 0.15);
          
          osc.connect(gain);
          gain.connect(audioCtx
            .destination);
          osc.start();
          osc.stop(t + 0.15);
        });
      },
      
      explode: () => {
        // Explosion is always loud (global event)
        if (audioCtx.state ===
          'suspended') audioCtx
          .resume();
        const t = audioCtx
          .currentTime;
        
        // ... (Your existing explode logic remains the same) ...
        const osc = audioCtx
          .createOscillator();
        const oscGain = audioCtx
          .createGain();
        osc.type = 'sawtooth';
        osc.frequency
          .setValueAtTime(60, t);
        osc.frequency
          .exponentialRampToValueAtTime(
            10, t + 1.2);
        oscGain.gain.setValueAtTime(
          3.0, t);
        oscGain.gain
          .exponentialRampToValueAtTime(
            0.01, t + 1.2);
        osc.connect(oscGain);
        oscGain.connect(audioCtx
          .destination);
        osc.start();
        osc.stop(t + 1.2);
        
        const bufferSize = audioCtx
          .sampleRate * 1.5;
        const buffer = audioCtx
          .createBuffer(1,
            bufferSize, audioCtx
            .sampleRate);
        const data = buffer
          .getChannelData(0);
        for (let i = 0; i <
          bufferSize; i++) data[i] =
          Math.random() * 2 - 1;
        const noise = audioCtx
          .createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx
          .createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency
          .setValueAtTime(600, t);
        const nGain = audioCtx
          .createGain();
        nGain.gain.setValueAtTime(
          2.5, t);
        nGain.gain
          .exponentialRampToValueAtTime(
            0.01, t + 1.2);
        noise.connect(filter);
        filter.connect(nGain);
        nGain.connect(audioCtx
          .destination);
        noise.start();
      }
    };
    
    
    /* --- CONFIG & STATE --- */
    const canvas = document
      .getElementById(
        'gameCanvas');
    const ctx = canvas.getContext(
      '2d');
    const ui = document
      .getElementById('ui-layer');
    
    let peer, conn, localStream;
    let isHost = false,
      gameActive = false,
      isGameOver = false;
    let worldSize = {
      w: 2400,
      h: 2400
    };
    let obstacles = [],
      particles = [],
      shockwaves = [];
    let myRematchReq = false,
      oppRematchReq = false;
    
    const FIRE_DELAY = 700;
    const RELOAD_TIME = 3000;
    const MAX_AMMO = 5;
    // TANK DIMENSIONS
    const TANK_W = 50;
    const TANK_H = 40;
    
    const player = {
      x: 0,
      y: 0,
      angle: 0,
      hp: 100,
      ammo: MAX_AMMO,
      bullets: [],
      lastFire: 0,
      lastReload: 0,
      color: '#4caf50'
    };
    
    const enemy = {
      x: -1000,
      y: -1000,
      angle: 0,
      hp: 100,
      bullets: [],
      color: '#f44336',
      dead: false
    };
    const keys = {};
    
    /* --- INITIALIZATION --- */
    let groundPattern;
    
    function createGround() {
      const off = document
        .createElement(
          'canvas');
      off.width = 200;
      off.height = 200;
      const octx = off.getContext(
        '2d');
      octx.fillStyle = '#3a4d2c';
      octx.fillRect(0, 0, 200,
        200);
      for (let i = 0; i <
        300; i++) {
        octx.fillStyle =
          `rgba(40, 60, 20, ${Math.random()*0.4})`;
        octx.fillRect(Math
          .random() * 200,
          Math.random() *
          200, 2, 5);
      }
      for (let i = 0; i <
        40; i++) {
        octx.fillStyle = Math
          .random() > 0.5 ?
          '#6b5b45' :
          '#7a7a7a';
        octx.beginPath();
        octx.arc(Math.random() *
          200, Math
          .random() * 200,
          Math.random() *
          3 + 1, 0, Math
          .PI * 2);
        octx.fill();
      }
      groundPattern = ctx
        .createPattern(off,
          'repeat');
    }
    
    /* --- NETWORKING --- */
    function showHost() {
      document.getElementById(
          'menu-main').style
        .display = 'none';
      document.getElementById(
          'menu-host').style
        .display = 'block';
      isHost = true;
      initPeer(Math.floor(100000 +
          Math.random() *
          900000)
        .toString());
    }
    
    function initPeer(id) {
      if (peer) peer.destroy();
      peer = new Peer(id);
      peer.on('open', (id) => {
        document
          .getElementById(
            'code-display'
          )
          .innerText =
          id;
      });
      peer.on('connection', (
        c) => {
        conn = c;
        if (isHost) {
          document
            .getElementById(
              'host-status'
            )
            .innerText =
            "Generating World...";
          conn.on('open',
            () => {
              genWorld
                ();
              const
                hostSpawn =
                getSafeSpawn(
                  null
                );
              resetPlayer
                (hostSpawn
                  .x,
                  hostSpawn
                  .y
                );
              const
                joinSpawn =
                getSafeSpawn(
                  hostSpawn
                );
              conn.send({
                type: 'init',
                world: obstacles,
                startX: joinSpawn
                  .x,
                startY: joinSpawn
                  .y
              });
              start
                ();
              setupAudio
                ();
            });
          setupConn();
        }
      });
      peer.on('call', (c) => {
        c.answer(
          localStream
        );
        c.on('stream',
          rs => {
            const
              audioEl =
              document
              .getElementById(
                'remote-audio'
              );
            audioEl
              .srcObject =
              rs;
            audioEl
              .play()
              .catch(
                e =>
                console
                .log(
                  "Audio play error:",
                  e
                )
              );
          });
      });
      peer.on('disconnected',
        handleOpponentDisconnect
      );
    }
    
    function joinGame() {
      const id = document
        .getElementById(
          'join-id').value;
      if (id.length < 6) return;
      isHost = false;
      document.getElementById(
          'btn-join')
        .innerText =
        "CONNECTING...";
      if (peer) peer.destroy();
      peer = new Peer();
      peer.on('open', () => {
        conn = peer
          .connect(
            id);
        setupConn();
      });
      peer.on('call', (c) => {
        c.answer(
          localStream
        );
        c.on('stream',
          rs => {
            document
              .getElementById(
                'remote-audio'
              )
              .srcObject =
              rs;
          });
      });
    }
    
    function setupConn() {
      conn.on('data', d => {
        if (d.type === 'init') {
          obstacles = d.world;
          resetPlayer(d.startX, d
            .startY);
          start();
          setupAudio();
        }
        
        if (d.type === 'update') {
          enemy.x = d.x;
          enemy.y = d.y;
          enemy.angle = d.angle;
          enemy.bullets = d.b;
          if (!enemy.dead) enemy
            .hp = d.hp;
        }
        
        
        if (d.type === 'fire') {
          SoundFX.shoot(d.x, d.y);
        }
        
        if (d.type === 'hit') {
          takeDamage(10);
          SoundFX.hit(player.x,
            player.y);
        }
        
        if (d.type === 'died')
          killEnemy();
        
        if (d.type ===
          'rematch_req') {
          oppRematchReq = true;
          checkRematch();
        }
        
        if (d.type === 'quit')
          handleOpponentDisconnect();
      });
      
      conn.on('close',
        handleOpponentDisconnect);
      conn.on('error', (err) => console
        .log("Conn Error: " + err));
    }
    
    
    function setupAudio() {
      navigator.mediaDevices
        .getUserMedia({ audio: true })
        .then(s => {
          localStream = s;
          localStream
            .getAudioTracks()[
              0]
            .enabled =
            false;
          if (conn && conn
            .peer) {
            const c =
              peer
              .call(
                conn
                .peer,
                s);
            c.on('stream',
              rs => {
                document
                  .getElementById(
                    'remote-audio'
                  )
                  .srcObject =
                  rs;
              });
          }
        })
        .catch(e => {
          console.log(
            "Mic Denied/Unavailable. Listener mode only."
          );
          localStream =
            null;
        });
    }
    
    function toggleMic() {
      if (!localStream) {
        alert(
          "Microphone access was denied or not found."
        );
        return;
      }
      const track = localStream
        .getAudioTracks()[0];
      track.enabled = !track
        .enabled;
      document.getElementById(
          'mic-btn').classList
        .toggle('on', track
          .enabled);
    }
    
    /* --- WORLD & SPAWN LOGIC --- */
    function genWorld() {
      obstacles = [];
      for (let i = 0; i <
        35; i++) {
        const r = 40 + Math
          .random() * 50;
        const pts = [];
        const segs = 6 + Math
          .floor(Math
            .random() * 4);
        for (let s = 0; s <
          segs; s++) {
          const a = (s /
              segs) * Math
            .PI * 2;
          const dist = r * (
            0.8 + Math
            .random() *
            0.4);
          pts.push({
            x: Math
              .cos(
                a
              ) *
              dist,
            y: Math
              .sin(
                a
              ) *
              dist
          });
        }
        obstacles.push({
          x: Math
            .random() *
            worldSize
            .w,
          y: Math
            .random() *
            worldSize
            .h,
          r: r,
          pts: pts,
          color: '#555'
        });
      }
    }
    
    function getSafeSpawn(
      avoidPoint) {
      let safe = false,
        x, y, attempts = 0;
      const minDistance = 1200;
      while (!safe && attempts <
        200) {
        attempts++;
        x = 100 + Math
          .random() * (
            worldSize
            .w - 200);
        y = 100 + Math
          .random() * (
            worldSize
            .h - 200);
        let isClean = true;
        if (checkCol(x, y, 60))
          isClean = false;
        if (avoidPoint &&
          isClean) {
          if (Math.hypot(x -
              avoidPoint
              .x, y -
              avoidPoint.y
            ) <
            minDistance)
            isClean = false;
        }
        if (isClean) safe =
          true;
      }
      if (!safe) {
        x = 200;
        y = 200;
      }
      return { x, y };
    }
    
    function handleQuit() {
      if (conn) {
        conn
          .send({ type: 'quit' });
        setTimeout(() => {
            conn
              .close();
          },
          100);
      }
      location.reload();
    }
    
    let disconnectTriggered = false;
    
    function handleOpponentDisconnect() {
      if (disconnectTriggered)
        return;
      disconnectTriggered = true;
      const modal = document
        .getElementById(
          'disconnect-modal');
      const msg = document
        .getElementById(
          'disconnect-msg');
      const cWin = document
        .getElementById(
          "checkWin")
      const timerEl = document
        .getElementById(
          'disconnect-timer');
      document.querySelectorAll(
          '.overlay-menu')
        .forEach(m => m.style
          .display = 'none');
      document.getElementById(
          'ui-layer').style
        .display = 'none';
      modal.style.display =
        'flex';
      if (!isGameOver) {
        msg.innerText =
          "MISSION SUCCESSFUL!";
        cWin.style.display =
          "block";
        msg.style.color =
          "#4caf50";
      } else {
        msg.innerText =
          "OPPONENT LEFT.";
        cWin.style.display =
          "none";
        msg.style.color =
          "#d32f2f";
      }
      let count = 3;
      timerEl.innerText = count;
      const interval =
        setInterval(() => {
          count--;
          timerEl
            .innerText =
            count;
          if (count <=
            0) {
            clearInterval
              (
                interval
              );
            location
              .reload();
          }
        }, 1000);
    }
    
    function requestRematch() {
      const btn = document
        .getElementById(
          'btn-rematch');
      btn.disabled = true;
      btn.innerText =
        "WAITING...";
      myRematchReq = true;
      if (conn) conn
        .send({ type: 'rematch_req' });
      checkRematch();
    }
    
    function checkRematch() {
      const msg = document
        .getElementById(
          'rematch-msg');
      if (oppRematchReq && !
        myRematchReq) {
        msg.innerText =
          "OPPONENT WANTS A REMATCH!";
        msg.style.animation =
          "pulse 1s infinite";
      }
      if (myRematchReq &&
        oppRematchReq) {
        resetGameParams();
        if (isHost) {
          genWorld();
          const hS =
            getSafeSpawn(
              null);
          resetPlayer(hS.x, hS
            .y);
          const jS =
            getSafeSpawn(
              hS);
          conn.send({
            type: 'init',
            world: obstacles,
            startX: jS
              .x,
            startY: jS
              .y
          });
          start();
        }
      }
    }
    
    function resetGameParams() {
      document.getElementById(
          'menu-over').style
        .display = 'none';
      document.getElementById(
          'btn-rematch')
        .disabled = false;
      document.getElementById(
          'btn-rematch')
        .innerText = "Rematch";
      document.getElementById(
          'rematch-msg')
        .innerText = "";
      enemy.hp = 100;
      enemy.dead = false;
      enemy.color = '#f44336';
      isGameOver = false;
      myRematchReq = false;
      oppRematchReq = false;
      shockwaves = [];
      particles = [];
    }
    
    /* --- GAMEPLAY --- */
    function resetPlayer(x, y) {
      player.x = x;
      player.y = y;
      player.hp = 100;
      player.color = '#4caf50';
      player.ammo =
        MAX_AMMO;
      player.angle = isHost ? 0 : Math
        .PI;
      player.lastReload = Date.now();
    }
    
    function start() {
      document.querySelectorAll(
          '.overlay-menu')
        .forEach(m => m.style
          .display = 'none');
      ui.style.display = 'block';
      if (/Android|iPhone/i.test(
          navigator.userAgent
        )) document
        .getElementById(
          'mobile-controls')
        .style.display =
        'block';
      if (!groundPattern)
        createGround();
      gameActive = true;
      isGameOver = false;
      if (audioCtx.state ===
        'suspended') audioCtx
        .resume();
      requestAnimationFrame(loop);
    }
    
    function takeDamage(v) {
      player.hp -= v;
      if (player.hp <= 0) {
        player.hp = 0;
        player.color =
          '#333333';
        updateHUD();
        conn
          .send({ type: 'died' });
        triggerBlast(player.x,
          player.y);
        setTimeout(() => {
            gameOver
              (
                false
              );
          },
          1500);
      } else {
        updateHUD();
      }
    }
    
    function killEnemy() {
      enemy.hp = 0;
      enemy.dead = true;
      enemy.color = '#333333';
      updateHUD();
      triggerBlast(enemy.x, enemy
        .y);
      setTimeout(() => {
          gameOver(
            true);
        },
        1500);
    }
    
    function triggerBlast(x, y) {
      SoundFX.explode();
      for (let i = 0; i <
        40; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math
              .random() -
              0.5
            ) *
            15,
          vy: (Math
              .random() -
              0.5
            ) *
            15,
          l: 50,
          c: '#f40'
        });
      }
      shockwaves.push({
        x: x,
        y: y,
        r: 10,
        maxR: 200,
        alpha: 1
      });
      document.body.classList
        .remove('shake-effect');
      void document.body
        .offsetWidth;
      document.body.classList.add(
        'shake-effect');
    }
    
    function fireBullet(e) {
      if (e) e.preventDefault();
      const now = Date.now();
      if (now - player.lastFire <
        FIRE_DELAY || player.ammo <= 0)
        return;
      
      player.lastFire = now;
      player.ammo--;
      player.lastReload = now;
      
      // 1. Play sound locally (no arguments = max volume)
      SoundFX.shoot();
      
      // 2. Send 'fire' event to network with current position
      if (conn) {
        conn.send({
          type: 'fire',
          x: player.x,
          y: player.y
        });
      }
      
      player.bullets.push({
        x: player.x + Math.cos(
          player.angle) * 35,
        y: player.y + Math.sin(
          player.angle) * 35,
        vx: Math.cos(player.angle) *
          15,
        vy: Math.sin(player.angle) *
          15,
        l: 100
      });
    }
    
    function loop() {
      if (!gameActive) return;
      update();
      draw();
      requestAnimationFrame(loop);
    }
    
    /* --- PHYSICS & COLLISION --- */
    function checkRectHit(bx, by,
      tx, ty, w, h, angle) {
      let dx = bx - tx;
      let dy = by - ty;
      let cos = Math.cos(angle);
      let sin = Math.sin(angle);
      let rx = dx * cos + dy *
        sin;
      let ry = -dx * sin + dy *
        cos;
      let pad = 8;
      let limitX = (w / 2) + pad;
      let limitY = (h / 2) + pad;
      return (Math.abs(rx) <=
        limitX && Math.abs(
          ry) <= limitY);
    }
    
    function update() {
      let spd = 0,
        turn = 0;
      if (keys['w']) spd = 4;
      if (keys['s']) spd = -3;
      if (keys['a']) turn = -0.05;
      if (keys['d']) turn = 0.05;
      if (joy.active) {
        player.angle = joy
          .angle;
        spd = 4 * joy.power;
      }
      
      player.angle += turn;
      const nx = player.x + Math
        .cos(player.angle) *
        spd;
      const ny = player.y + Math
        .sin(player.angle) *
        spd;
      
      if (!checkCol(nx, ny, 25)) {
        player.x = nx;
        player.y = ny;
      }
      
      for (let i = player.bullets
          .length - 1; i >=
        0; i--) {
        let b = player.bullets[
          i];
        b.x += b.vx;
        b.y += b.vy;
        b.l--;
        
        if (checkCol(b.x, b.y,
            5, true)) b.l =
          0;
        
        if (!enemy.dead && b.l >
          0) {
          if (checkRectHit(b
              .x, b.y,
              enemy.x,
              enemy.y,
              TANK_W,
              TANK_H,
              enemy.angle
            )) {
            b.l = 0;
            SoundFX.hit();
            conn
              .send({ type: 'hit' });
            particles.push({
              x: b.x,
              y: b.y,
              vx: 0,
              vy: 0,
              l: 10,
              c: '#fff'
            });
          }
        }
        if (b.l <= 0) player
          .bullets.splice(i,
            1);
      }
      
      if (conn) conn.send({
        type: 'update',
        x: player.x,
        y: player.y,
        angle: player
          .angle,
        hp: player.hp,
        b: player
          .bullets
      });
      
      
      // Reload logic
      if (player.ammo <
        MAX_AMMO
      ) {
        if (Date.now() - player
          .lastReload >
          RELOAD_TIME) {
          player.ammo++;
          player.lastReload =
            Date.now();
        }
      }
      
    }
    
    function checkCol(x, y, r,
      ignoreEnemy = false) {
      if (x < 0 || x > worldSize
        .w || y < 0 || y >
        worldSize.h)
        return true;
      for (let o of obstacles) {
        if (Math.hypot(x - o.x,
            y - o.y) < o.r +
          r) return true;
      }
      if (!ignoreEnemy && !enemy
        .dead && Math.hypot(x -
          enemy.x, y - enemy.y
        ) < 50) return true;
      return false;
    }
    
    function draw() {
      canvas.width = window
        .innerWidth;
      canvas.height = window
        .innerHeight;
      
      let cx = Math.max(0, Math
        .min(player.x -
          canvas.width /
          2, worldSize.w -
          canvas.width));
      let cy = Math.max(0, Math
        .min(player.y -
          canvas.height /
          2, worldSize.h -
          canvas.height));
      
      ctx.save();
      ctx.translate(-cx, -cy);
      
      // 1. Draw Ground
      ctx.fillStyle =
        groundPattern;
      ctx.fillRect(0, 0, worldSize
        .w, worldSize.h);
      
      // 2. Draw Obstacles
      obstacles.forEach(o => {
        ctx.fillStyle =
          o.color;
        ctx.beginPath();
        ctx.moveTo(o.x +
          o.pts[0]
          .x, o
          .y + o
          .pts[0]
          .y);
        o.pts.forEach(
          p => ctx
          .lineTo(
            o
            .x +
            p.x,
            o
            .y +
            p.y)
        );
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      });
      drawTank(player);
      if (enemy.x > -500) {
        drawTank(enemy);
      }
      
      // Draw Bullets
      ctx.fillStyle = '#ffd700';
      [...player.bullets, ...enemy
        .bullets
      ].forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b
          .y, 4,
          0, Math
          .PI * 2);
        ctx.fill();
      });
      
      //Draw Particles
      particles.forEach((p,
        i) => {
        ctx.fillStyle =
          p.c;
        ctx.beginPath();
        ctx.arc(p.x, p
          .y, 3,
          0, Math
          .PI * 2);
        ctx.fill();
        p.x += p.vx;
        p.y += p.vy;
        p.l--;
        if (p.l <= 0)
          particles
          .splice(i,
            1);
      });
      //Draw Shockwaves
      shockwaves.forEach((s,
        i) => {
        ctx.beginPath();
        ctx.arc(s.x, s
          .y, s.r,
          0, Math
          .PI * 2);
        ctx.lineWidth =
          10 * s
          .alpha;
        ctx.strokeStyle =
          `rgba(255, 200, 50, ${s.alpha})`;
        ctx.stroke();
        s.r += 8;
        s.alpha -= 0.05;
        if (s.alpha <=
          0)
          shockwaves
          .splice(i,
            1);
      });
      
      ctx.restore();
      updateHUD();
    }
    
    function drawTank(t) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate(t.angle);
      ctx.fillStyle = t.color;
      ctx.fillRect(-25, -20, 50,
        40);
      ctx.fillStyle = '#222';
      ctx.fillRect(-30, -22, 60,
        8);
      ctx.fillRect(-30, 14, 60,
        8);
      ctx.fillRect(0, -4, 40, 8);
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math
        .PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    function updateHUD() {
      document.getElementById(
          'hp-local').style.width =
        player.hp + '%';
      document.getElementById(
          'hp-remote').style.width =
        enemy.hp + '%';
      
      const container = document
        .getElementById('ammo-count');
      const statusText = document
        .getElementById('ammo-status');
      container.innerHTML = '';
      const isReloading = player.ammo <
        MAX_AMMO;
      statusText.innerText =
        isReloading ? "Reloading..." :
        "Full Ammo";
      if(isReloading){
        statusText.classList.add('reload')
      }else{
        statusText.classList.remove('reload')
      }
      for (let i = 0; i <
        MAX_AMMO; i++) {
        const b = document
          .createElement('div');
        if (i < player.ammo) {
          b.className = 'bullet active';
        } else if (i === player.ammo &&
          isReloading) {
          b.className =
            'bullet loading';
        } else {
          b.className = 'bullet';
        }
        
        container.appendChild(b);
      }
      
      if (!enemy.dead) drawTracker();
    }
    
    function drawTracker() {
      const dx = enemy.x - player
        .x,
        dy = enemy.y - player.y;
      const angle = Math.atan2(dy,
        dx);
      ctx.save();
      ctx.translate(canvas.width /
        2 + Math.cos(
          angle) * 80,
        canvas
        .height / 2 + Math
        .sin(angle) * 80);
      ctx.rotate(angle);
      ctx.fillStyle =
        'rgba(255,0,0,0.5)';
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(-5, 7);
      ctx.lineTo(-5, -7);
      ctx.fill();
      ctx.restore();
    }
    
    function gameOver(win) {
      gameActive = false;
      isGameOver = true;
      document.getElementById(
          'menu-over').style
        .display = 'block';
      const title = document
        .getElementById(
          'over-title');
      title.innerText = win ?
        "MISSION COMPLETE." :
        "MISSION ABORTED.";
      title.style.color = win ?
        "#4caf50" : "#f44336";
    }
    
    function copyCode() {
      const code = document
        .getElementById(
          'code-display')
        .innerText;
      navigator.clipboard
        .writeText(code);
    }
    
    window.onkeydown = e => keys[e
        .key.toLowerCase()] =
      true;
    window.onkeyup = e => keys[e.key
      .toLowerCase()] = false;
    
    const joy = {
      active: false,
      angle: 0,
      power: 0
    };
    const jBase = document
      .getElementById('joy-base'),
      jStick = document
      .getElementById(
        'joy-stick');
    jBase.addEventListener(
      'touchstart', (e) => {
        joy.active = true;
        handleJoy(e);
      });
    jBase.addEventListener(
      'touchmove', handleJoy);
    jBase.addEventListener(
      'touchend', () => {
        joy.active = false;
        jStick.style.left =
          '50%';
        jStick.style.top =
          '50%';
      });
    
    function handleJoy(e) {
      if (!joy.active) return;
      const touch = e.touches[0],
        rect = jBase
        .getBoundingClientRect();
      const dx = touch.clientX - (
          rect.left + 60),
        dy = touch.clientY - (
          rect.top + 60);
      const dist = Math.min(60,
        Math.hypot(dx, dy));
      joy.angle = Math.atan2(dy,
        dx);
      joy.power = dist / 60;
      jStick.style.left = 50 + (
        Math.cos(joy
          .angle) * joy
        .power * 50) + '%';
      jStick.style.top = 50 + (
        Math.sin(joy
          .angle) * joy
        .power * 50) + '%';
    }
  </script>
</body>

</html>